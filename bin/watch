#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long ();
use Pod::Usage   ();
use File::ChangeNotify;
use Cwd          ();
use Config::Tiny ();

Getopt::Long::GetOptions(
    \my %opt,
    'help',
) or Pod::Usage::pod2usage( -exitval => 1 );

if ($opt{help}) {
    Pod::Usage::pod2usage( -exitval => 0 );
}

Pod::Usage::pod2usage( -message => 'Argument command is required', -exitval => 1 )
    unless @ARGV;

my $dir    = Cwd::getcwd();
my $config = load_config($dir);

my $commands = [];
foreach my $key (@ARGV) {
    Pod::Usage::pod2usage( -message => "Argument $key is not a defined command", -exitval => 1 )
        unless defined $config->{command}{$key};

    push @{$commands}, { $key => $config->{command}{$key} };
}

my $dir_exclude = $dir . "/(?:.+\/)?";
my $exclude = [
    qr($dir_exclude\.),  # dotfiles or dot directory names
    sub { -e && !-r },
];

foreach my $key ( keys %{$config->{ignore}} ) {
    my $string = $config->{ignore}{$key};
    $string =~ s/\s+//g;
    logger( "ignore", $string );

    my @ignores;
    if ( $string =~ /,/ ) {
        @ignores = split /,/, $string;
    }
    push @{$exclude}, map { qr($dir_exclude$_) } @ignores;
}

my $watcher =
    File::ChangeNotify->instantiate_watcher(
        directories => [ $dir ],
        exclude     => $exclude,
        follow_symlinks => 0,
    );

logger( 'watch', $dir );

while ( my @events = $watcher->wait_for_events ) {
    logger( $events[0]->{type}, $events[0]->{path} );
    run_commands($commands);
}

exit 0;

sub logger {
    my $event = shift;
    my $entry = shift;

    if ( $event eq 'fatal' ) {
        die "[" . time . "][$event]: " . "$entry\n";
    }
    else {
        print "[" . time . "][$event]: " . "$entry\n";
    }

    return;
}

sub load_config {
    my $dir = shift;
    my $rc  = "$dir/.watch";

    unless ( -e $rc && -r $rc ) {
        die "$0: $rc does not exist or cannot be read\n";
    }

    my $config = Config::Tiny->read($rc);

    foreach my $required (qw{ command }) {
        unless ( defined $config->{$required} ) {
            die "$0: $required section in $rc is required\n";
        }
    }

    return $config;
}

sub run_commands {
    my $commands = shift;

    foreach my $command (@{$commands}) {
        my $key     = ( keys %{$command} )[0];
        my $command = ( values %{$command} )[0];

        logger( "run $key", $command );
        system($command);
        logger( "fatal", "run $key failed; exiting" ) if $?;
    }

    return;
}

__END__

=pod

=head1 NAME

watch - run commands when files change

=head1 SYNOPSIS

 watch <command> [--help]

=head1 DESCRIPTION

C<watch> is a program that watches for changes to files and directories then runs configured sets of commands.

C<watch> detects changes recursively from the current working directory.  Files/directories to ignore and commands to run are read from the C<.watch> file within the current working directory.

=head1 OPTIONS

=over

=item --help

Print the help menu.

=back

=head1 CONFIGURATION

=head2 ignore

The C<ignore> section key.

Keys within this section define additional file or directory names to ignore.

Multiple file or directory names can be defined per line if separated by comma.

 [ignore]
 dirs=blib, tmp
 files=pm_to_blib, scratch

=head2 command

The C<command> section key.

Keys within this section define what command to run when that command argument is passed.

 [command]
 install=sudo make && sudo make install
 dir_list=ls -lah
 date=date

Defined commands are run as arguments to C<watch>.  Multiple commands are run in the order they're passed.

 $ watch install dir_list date
 (will run install, then dir_list, then date)

=head2 EXAMPLES

=over

=item Automatically build and install a Perl module after editing

 # create a .watch file in the directory to watch
 ~/git/bestpractical/bps/rt-extension-mandatoryontransition (add-config-verification) $ vi .watch
 [ignore]
 dirs=blib, tmp
 files=pm_to_blib, scratch

 [command]
 install=sudo make && sudo make install

 # run watch with the "install" argument to run "sudo make && sudo make install" when files or dirs change
 ~/git/bestpractical/bps/rt-extension-mandatoryontransition (add-config-verification) $ watch install
 [1617569718][ignore]: blib,tmp
 [1617569718][ignore]: pm_to_blib,scratch
 [1617569718][watch]: /home/blaine/git/bestpractical/bps/rt-extension-mandatoryontransition

 # after modifying the file, MandatoryOnTransition.pm, the "install" command is run

 [1617569728][modify]: /home/blaine/git/bestpractical/bps/rt-extension-mandatoryontransition/lib/RT/Extension/MandatoryOnTransition.pm
 [1617569728][run install]: sudo make && sudo make install
 cp lib/RT/Extension/MandatoryOnTransition/Test.pm blib/lib/RT/Extension/MandatoryOnTransition/Test.pm
 cp lib/RT/Extension/MandatoryOnTransition.pm blib/lib/RT/Extension/MandatoryOnTransition.pm
 cp lib/RT/Extension/MandatoryOnTransition/Test.pm.in blib/lib/RT/Extension/MandatoryOnTransition/Test.pm.in
 Manifying blib/man3/RT::Extension::MandatoryOnTransition.3
 Appending installation info to /home/blaine/src/rts/rt50-trunk_sqlite/local/plugins/RT-Extension-MandatoryOnTransition/lib/perllocal.pod

=item Run multiple commands when changes are detected

 # add three more commands to the .watch file
 ~/git/bestpractical/bps/rt-extension-mandatoryontransition (add-config-verification) $ vi .watch
 [ignore]
 dirs=blib, tmp
 files=pm_to_blib, scratch

 [command]
 install=sudo make && sudo make install
 example=echo 'this is an example command'
 another_example=echo 'this is another example command'
 date=date

 blaine@cyon ~/git/bestpractical/bps/rt-extension-mandatoryontransition (master) $ watch example another_example date
 [1617573990][ignore]: pm_to_blib,scratch
 [1617573990][ignore]: blib,tmp
 [1617573990][watch]: /home/blaine/git/bestpractical/bps/rt-extension-mandatoryontransition
 [1617574000][modify]: /home/blaine/git/bestpractical/bps/rt-extension-mandatoryontransition/lib/RT/Extension/MandatoryOnTransition.pm
 [1617574000][run example]: echo 'this is an example command'
 this is an example command
 [1617574000][run another_example]: echo 'this is another example command'
 this is another example command
 [1617574000][run date]: date
 Sun Apr  4 17:06:40 CDT 2021

=back

=cut
